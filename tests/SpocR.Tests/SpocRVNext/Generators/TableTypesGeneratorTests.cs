using System;
using System.IO;
using System.Linq;
using Xunit;
using SpocR.SpocRVNext.Configuration;
using SpocR.SpocRVNext.Metadata;
using SpocR.SpocRVNext.Generators;

namespace SpocR.Tests.SpocRVNext.Generators;

public class TableTypesGeneratorTests
{
    [Fact]
    public void GeneratesFiles_WithStubProvider()
    {
        var root = Directory.CreateTempSubdirectory();
        File.WriteAllText(Path.Combine(root.FullName, ".env"), "SPOCR_NAMESPACE=Test.App\nSPOCR_BUILD_SCHEMAS=Alpha\nSPOCR_GENERATOR_DB=Server=test;Database=db;\n");
        var cfg = EnvConfiguration.Load(projectRoot: root.FullName);
        var stub = new StubProvider(("Alpha", "UserIdList"));
        var templatesDir = Path.Combine(root.FullName, "src", "SpocRVNext", "Templates");
        Directory.CreateDirectory(templatesDir);
        File.WriteAllText(Path.Combine(templatesDir, "ITableType.spt"), "// <auto-generated/>\nnamespace {{ Namespace }};\npublic interface ITableType {}\n");
        File.WriteAllText(Path.Combine(templatesDir, "TableType.spt"), "// <auto-generated/>\nnamespace {{ Namespace }}.{{ Schema }};\npublic readonly record struct {{ TypeName }}(\n{{#each Columns}}    {{ ClrType }} {{ PropertyName }}{{ Separator }}\n{{/each}}) : ITableType {}\n");
        var loader = new SpocR.SpocRVNext.Engine.FileSystemTemplateLoader(templatesDir);
        var gen = new TableTypesGenerator(cfg, stub, new SpocR.SpocRVNext.Engine.SimpleTemplateEngine(), loader, root.FullName);
        var count = gen.Generate();
        Assert.True(count >= 2);
        var outDir = Path.Combine(root.FullName, cfg.OutputDir!, "Alpha");
        Assert.True(Directory.Exists(outDir));
        var files = Directory.GetFiles(outDir, "*.cs");
        Assert.Contains(files, f => f.EndsWith("UserIdList.cs"));
    }

    [Fact]
    public void Filters_TableTypes_By_BuildSchemas_AllowList()
    {
        var root = Directory.CreateTempSubdirectory();
        // Only allow schema 'Alpha'
        File.WriteAllText(Path.Combine(root.FullName, ".env"), "SPOCR_NAMESPACE=Test.App\nSPOCR_BUILD_SCHEMAS=Alpha\nSPOCR_TABLETYPES_MODE=strict\nSPOCR_GENERATOR_DB=Server=test;Database=db;\n");
        var cfg = EnvConfiguration.Load(projectRoot: root.FullName);
        var stub = new StubProvider(
            ("Alpha", "UserImport"),
            ("Beta", "OtherType")
        );
        var loader = new InMemoryTemplateLoader();
        var gen = new TableTypesGenerator(cfg, stub, new SpocR.SpocRVNext.Engine.SimpleTemplateEngine(), loader, root.FullName);
        var count = gen.Generate();
        // Expect: 1 interface (ITableType.cs) + 1 TableType from Alpha = 2 total writes
        Assert.Equal(2, count);
        var outDir = Path.Combine(root.FullName, cfg.OutputDir!);
        var alphaDir = Path.Combine(outDir, "Alpha");
        var betaDir = Path.Combine(outDir, "Beta");
        Assert.True(Directory.Exists(alphaDir), "Alpha directory should exist");
        Assert.False(Directory.Exists(betaDir), "Beta schema should be filtered out");
        var alphaFiles = Directory.GetFiles(alphaDir, "*.cs");
        Assert.Contains(alphaFiles, f => f.EndsWith("UserImport.cs"));
    }

    [Fact]
    public void PreservesOriginalNames_NoRenaming()
    {
        var root = Directory.CreateTempSubdirectory();
        File.WriteAllText(Path.Combine(root.FullName, ".env"), "SPOCR_NAMESPACE=Test.App\nSPOCR_GENERATOR_DB=Server=test;Database=db;\n");
        var cfg = EnvConfiguration.Load(projectRoot: root.FullName);
        var stub = new StubProvider(
            ("dbo", "CustomerTT"),
            ("dbo", "ImportUDTT"),
            ("dbo", "PriceType"),
            ("dbo", "AlreadyTableType")
        );
        var loader = new InMemoryTemplateLoader();
        var gen = new TableTypesGenerator(cfg, stub, new SpocR.SpocRVNext.Engine.SimpleTemplateEngine(), loader, root.FullName);
        var count = gen.Generate();
        Assert.Equal(5, count);
        var outDir = Path.Combine(root.FullName, cfg.OutputDir!, "dbo");
        var files = Directory.GetFiles(outDir, "*.cs");
        Assert.Contains(files, f => f.EndsWith("CustomerTT.cs"));
        Assert.Contains(files, f => f.EndsWith("ImportUDTT.cs"));
        Assert.Contains(files, f => f.EndsWith("PriceType.cs"));
        Assert.Contains(files, f => f.EndsWith("AlreadyTableType.cs"));
    }

    private sealed class StubProvider : ITableTypeMetadataProvider
    {
        private readonly IReadOnlyList<TableTypeInfo> _items;
        public StubProvider(params (string Schema, string Name)[] names)
        {
            _items = names.Select(n => new TableTypeInfo
            {
                Schema = n.Schema,
                Name = n.Name,
                Columns = new[] { new ColumnInfo { Name = "Id", SqlType = "int", IsNullable = false } }
            }).ToList();
        }
        public IReadOnlyList<TableTypeInfo> GetAll() => _items;
    }

    private sealed class InMemoryTemplateLoader : SpocR.SpocRVNext.Engine.ITemplateLoader
    {
        public IEnumerable<string> ListNames() => new[] { "ITableType", "TableType" };
        public bool TryLoad(string name, out string template)
        {
            template = name switch
            {
                "ITableType" => "// <auto-generated/>\nnamespace {{ Namespace }};\npublic interface ITableType {}\n",
                "TableType" => "// <auto-generated/>\nnamespace {{ Namespace }}.{{ Schema }};\npublic readonly record struct {{ TypeName }}(\n{{#each Columns}}    {{ ClrType }} {{ PropertyName }}{{ Separator }}\n{{/each}}) : ITableType {}\n",
                _ => string.Empty
            };
            return !string.IsNullOrEmpty(template);
        }
    }
}

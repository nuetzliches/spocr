using System;
using System.IO;
using System.Linq;
using Xunit;
using SpocR.SpocRVNext.Engine;
using SpocR.SpocRVNext.Metadata;
using SpocR.SpocRVNext.Generators;
using SpocR.SpocRVNext.Models; // StoredProcedureContentModel for resolver delegate

namespace SpocR.Tests.SpocRVNext.Generators;

/// <summary>
/// Verifies that a deferred JSON function container column (Reference.Kind==Function + DeferredJsonExpansion=true)
/// is expanded at generation-time into dot-path leaf fields and nested record types.
/// </summary>
public class DeferredJsonFunctionExpansionTests
{
    [Fact]
    public void DeferredFunctionContainer_Should_Expand_DotPath_Fields()
    {
        // Arrange: static resolver returns two JSON columns for RecordAsJson
        StoredProcedureContentModel.ResolveFunctionJsonSet = (schema, name) =>
        {
            if (name == "RecordAsJson")
            {
                return (ReturnsJson: true, ReturnsJsonArray: false, RootProperty: "record", ColumnNames: new[] { "id", "statusCode" });
            }
            return (false, false, string.Empty, Array.Empty<string>());
        };

        var root = Path.Combine(Path.GetTempPath(), "spocr-deferred-fn-exp-" + Guid.NewGuid().ToString("N"));
        var schemaDir = Path.Combine(root, ".spocr", "schema");
        Directory.CreateDirectory(schemaDir);
        // Minimal legacy snapshot with one procedure having a JSON ResultSet and a single deferred function container column
        // NOTE: ResultSet name will be auto-derived as ResultSet1 (index+1)
        var json = "{\n  \"Procedures\": [\n    { \"Schema\": \"identity\", \"Name\": \"RecordFetch\", \"ResultSets\": [ { \"ReturnsJson\": true, \"ReturnsJsonArray\": false, \"Columns\": [ { \"Name\": \"record\", \"SqlTypeName\": \"nvarchar(max)\", \"IsNullable\": false, \"Reference\": { \"Kind\": \"Function\", \"Schema\": \"identity\", \"Name\": \"RecordAsJson\" }, \"DeferredJsonExpansion\": true } ] } ] }\n  ]\n}";
        File.WriteAllText(Path.Combine(schemaDir, "snapshot.json"), json);

        var provider = new SchemaMetadataProvider(root);
        var engine = new SimpleTemplateEngine();
        var repoRoot = DeriveRepoRootFromAssembly();
        var loader = InMemoryTemplateLoader.Create(repoRoot);
        var gen = new ProceduresGenerator(engine, () => provider.GetProcedures(), loader, root, null);
        var outDir = Path.Combine(root, "generated");
        Directory.CreateDirectory(outDir);

        // Act
        gen.Generate("TestNs", outDir);
        var file = Directory.GetFiles(outDir, "RecordFetch.cs", SearchOption.AllDirectories).FirstOrDefault()
                   ?? Directory.GetFiles(outDir, "*.cs", SearchOption.AllDirectories).First();
        var code = File.ReadAllText(file);

        // Assert: Nested type generated for 'record' group and leaf fields expanded
        // Root ResultSet type name pattern: RecordFetchResultSet1Result
        Assert.Contains("record", code); // group property
        Assert.Contains("RecordFetchResultSet1RecordResult", code); // nested record type name
        Assert.Contains("id", code); // leaf property name inside nested record
        Assert.Contains("statusCode", code); // second leaf
        // Original container column should NOT remain as a flat field expression (no ReaderUtil.TryGetOrdinal for 'record')
        Assert.DoesNotContain("TryGetOrdinal(r, \"record\")", code);

        // Cleanup resolver to avoid leaking into other tests
        StoredProcedureContentModel.ResolveFunctionJsonSet = null;
    }

    private sealed class InMemoryTemplateLoader : SpocR.SpocRVNext.Engine.ITemplateLoader
    {
        private readonly System.Collections.Generic.Dictionary<string, string> _templates;
        private InMemoryTemplateLoader(System.Collections.Generic.Dictionary<string, string> templates) { _templates = templates; }
        public static InMemoryTemplateLoader Create(string repoRoot)
        {
            var dict = new System.Collections.Generic.Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            string unifiedPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "Procedures", "UnifiedProcedure.spt");
            string headerPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "_Header.spt");
            if (File.Exists(unifiedPath)) dict["UnifiedProcedure"] = File.ReadAllText(unifiedPath);
            if (File.Exists(headerPath)) dict["_Header"] = File.ReadAllText(headerPath); else dict["_Header"] = "// <auto-generated/>";
            return new InMemoryTemplateLoader(dict);
        }
        public bool TryLoad(string name, out string content) => _templates.TryGetValue(name, out content);
        public System.Collections.Generic.IEnumerable<string> ListNames() => _templates.Keys;
    }

    private static string DeriveRepoRootFromAssembly()
    {
        var baseDir = AppContext.BaseDirectory; // tests bin path
        var dir = new DirectoryInfo(baseDir);
        for (int i = 0; i < 12 && dir != null; i++)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, "src", "SpocRVNext", "Templates"))) return dir.FullName;
            dir = dir.Parent;
        }
        return Directory.GetCurrentDirectory();
    }
}

using System;
using System.IO;
using System.Linq;
using Xunit;
using SpocR.SpocRVNext.Engine;
using SpocR.SpocRVNext.Metadata;
using SpocR.SpocRVNext.Generators;

namespace SpocR.Tests.SpocRVNext.Generators;

/// <summary>
/// Verifies generator emits correct deserialization shape (List<T> population) for JSON array vs single object payloads.
/// Focus: ReturnsJsonArray flag influences generated fallback code path.
/// We inspect generated code fragments rather than executing DB roundtrip.
/// </summary>
public class JsonResultSetDeserializationShapeTests
{
    [Fact]
    public void ReturnsJsonArray_True_Should_Use_List_Deserialize_Path()
    {
        var (code, _) = GenerateSingleJsonProcedure(returnsJsonArray: true);
        // Expect generator fallback code to contain List<...> deserialization pattern (__list variable)
        Assert.Contains("JsonSerializer.Deserialize<System.Collections.Generic.List", code);
        Assert.Contains("__list", code);
        // Should NOT contain single object variable name __single
        Assert.DoesNotContain("__single", code);
    }

    [Fact]
    public void ReturnsJsonArray_False_Should_Use_Single_Object_Path()
    {
        var (code, _) = GenerateSingleJsonProcedure(returnsJsonArray: false);
        // Expect single object deserialization path (__single variable)
        Assert.Contains("JsonSerializer.Deserialize<", code);
        Assert.Contains("__single", code);
        // Should not contain generic List<T> deserialize fallback for this result set
        Assert.DoesNotContain("JsonSerializer.Deserialize<System.Collections.Generic.List", code);
    }

    private static (string code, string filePath) GenerateSingleJsonProcedure(bool returnsJsonArray)
    {
        var root = Path.Combine(Path.GetTempPath(), "spocr-json-shape-" + Guid.NewGuid().ToString("N"));
        var schemaDir = Path.Combine(root, ".spocr", "schema");
        Directory.CreateDirectory(schemaDir);
        var sqlFlag = returnsJsonArray ? string.Empty : ", WITHOUT_ARRAY_WRAPPER";
        var returnsArrayLiteral = returnsJsonArray ? "true" : "false";
        // Use classic interpolated string with escaped braces for JSON structure
        var json = $"{{\n  \"Procedures\": [\n    {{\n      \"Name\": \"StatusFindAsJson\",\n      \"SchemaName\": \"dbo\",\n      \"OperationName\": \"dbo__StatusFindAsJson\",\n      \"Sql\": \"CREATE PROCEDURE dbo.StatusFindAsJson AS SELECT CAST(1 as int) as statusId, CAST(1 as bit) as isActive FOR JSON PATH{sqlFlag};\",\n      \"InputParameters\": [],\n      \"OutputParameters\": [],\n      \"ResultSets\": [\n        {{\n          \"ReturnsJson\": true,\n          \"ReturnsJsonArray\": {returnsArrayLiteral},\n          \"Columns\": [\n            {{ \"Name\": \"statusId\", \"SqlTypeName\": \"int\", \"IsNullable\": false }},\n            {{ \"Name\": \"isActive\", \"SqlTypeName\": \"bit\", \"IsNullable\": false }}\n          ]\n        }}\n      ]\n    }}\n  ]\n}}";
        File.WriteAllText(Path.Combine(schemaDir, "legacy.json"), json);
        var provider = new SchemaMetadataProvider(root);
        var engine = new SimpleTemplateEngine();
        var repoRoot = DeriveRepoRootFromAssembly();
        var loader = InMemoryTemplateLoader.Create(repoRoot);
        var gen = new ProceduresGenerator(engine, () => provider.GetProcedures(), loader, root, null);
        var outDir = Path.Combine(root, "generated");
        Directory.CreateDirectory(outDir);
        gen.Generate("TestNs", outDir);
        var file = Directory.GetFiles(outDir, "*.cs", SearchOption.AllDirectories).First();
        var code = File.ReadAllText(file);
        return (code, file);
    }

    private sealed class InMemoryTemplateLoader : SpocR.SpocRVNext.Engine.ITemplateLoader
    {
        private readonly System.Collections.Generic.Dictionary<string, string> _templates;
        private InMemoryTemplateLoader(System.Collections.Generic.Dictionary<string, string> templates) { _templates = templates; }
        public static InMemoryTemplateLoader Create(string repoRoot)
        {
            var dict = new System.Collections.Generic.Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            string unifiedPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "Procedures", "UnifiedProcedure.spt");
            string headerPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "_Header.spt");
            if (File.Exists(unifiedPath)) dict["UnifiedProcedure"] = File.ReadAllText(unifiedPath);
            if (File.Exists(headerPath)) dict["_Header"] = File.ReadAllText(headerPath); else dict["_Header"] = "// <auto-generated/>";
            return new InMemoryTemplateLoader(dict);
        }
        public bool TryLoad(string name, out string content) => _templates.TryGetValue(name, out content);
        public System.Collections.Generic.IEnumerable<string> ListNames() => _templates.Keys;
    }

    private static string DeriveRepoRootFromAssembly()
    {
        var baseDir = AppContext.BaseDirectory; // tests bin path
        var dir = new DirectoryInfo(baseDir);
        for (int i = 0; i < 12 && dir != null; i++)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, "src", "SpocRVNext", "Templates"))) return dir.FullName;
            dir = dir.Parent;
        }
        return Directory.GetCurrentDirectory();
    }
}

using System;
using System.IO;
using System.Linq;
using Xunit;
using SpocR.SpocRVNext.Engine;
using SpocR.SpocRVNext.Metadata;
using SpocR.SpocRVNext.Generators;

namespace SpocR.Tests.SpocRVNext.Generators;

public class CrossSchemaExecForwardingDiagnostics
{
    [Fact]
    public void Dump_Mixed_And_Wrapper_Generated_Code()
    {
        DumpVariant("WrapperOnlyTest", wrapperOnly: true);
        DumpVariant("MixedWrapperTest", wrapperOnly: false);
    }

    private static void DumpVariant(string testPrefix, bool wrapperOnly)
    {
        var root = Path.Combine(Path.GetTempPath(), "spocr-xschema-diag-" + testPrefix + "-" + Guid.NewGuid().ToString("N"));
        var schemaDir = Path.Combine(root, ".spocr", "schema");
        Directory.CreateDirectory(schemaDir);
        string wrapperSetsJsonPart = wrapperOnly
            ? "\n                  \"ResultSets\": [ { \"ExecSourceSchemaName\": \"other\", \"ExecSourceProcedureName\": \"TargetProc\", \"Columns\": [] } ]"
            : "\n                  \"ResultSets\": [ { \"Name\": \"OwnSet\", \"Columns\": [ { \"Name\": \"id\", \"SqlTypeName\": \"int\" } ] }, { \"ExecSourceSchemaName\": \"other\", \"ExecSourceProcedureName\": \"TargetProc\", \"Columns\": [] } ]";
        var json = $"{{\n  \"Procedures\": [\n    {{\n      \"Name\": \"TargetProc\",\n      \"SchemaName\": \"other\",\n      \"OperationName\": \"other__TargetProc\",\n      \"Sql\": \"CREATE PROCEDURE other.TargetProc AS SELECT 1 as a; SELECT 2 as b;\",\n      \"InputParameters\": [],\n      \"OutputParameters\": [],\n      \"ResultSets\": [\n        {{ \"Name\": \"ResultSetA\", \"Columns\": [ {{ \"Name\": \"a\", \"SqlTypeName\": \"int\" }} ] }},\n        {{ \"Name\": \"ResultSetB\", \"Columns\": [ {{ \"Name\": \"b\", \"SqlTypeName\": \"int\" }} ] }}\n      ]\n    }},\n    {{\n      \"Name\": \"{testPrefix}\",\n      \"SchemaName\": \"dbo\",\n      \"OperationName\": \"dbo__{testPrefix}\",\n      \"Sql\": \"CREATE PROCEDURE dbo.{testPrefix} AS EXEC other.TargetProc;\",\n      \"InputParameters\": [],\n      \"OutputParameters\": [],{wrapperSetsJsonPart}\n    }}\n  ]\n}}";
        File.WriteAllText(Path.Combine(schemaDir, "legacy.json"), json);
        var provider = new SchemaMetadataProvider(root);
        var engine = new SimpleTemplateEngine();
        var repoRoot = DeriveRepoRootFromAssembly();
        var loader = InMemoryTemplateLoader.Create(repoRoot);
        var gen = new ProceduresGenerator(engine, () => provider.GetProcedures(), loader, root, null);
        var outDir = Path.Combine(root, "generated");
        Directory.CreateDirectory(outDir);
        gen.Generate("TestNs", outDir);
        var file = Directory.GetFiles(outDir, "*.cs", SearchOption.AllDirectories)
            .Select(f => new { f, text = File.ReadAllText(f) })
            .First(x => x.text.Contains(testPrefix));
        var code = file.text;
        var debugDir = Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "..", "debug");
        Directory.CreateDirectory(debugDir);
        File.WriteAllText(Path.Combine(debugDir, $"CrossSchemaForwarding_{testPrefix}.generated.cs.txt"), code);
    }

    private sealed class InMemoryTemplateLoader : SpocR.SpocRVNext.Engine.ITemplateLoader
    {
        private readonly System.Collections.Generic.Dictionary<string, string> _templates;
        private InMemoryTemplateLoader(System.Collections.Generic.Dictionary<string, string> templates) { _templates = templates; }
        public static InMemoryTemplateLoader Create(string repoRoot)
        {
            var dict = new System.Collections.Generic.Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            string unifiedPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "Procedures", "UnifiedProcedure.spt");
            string headerPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "_Header.spt");
            if (File.Exists(unifiedPath)) dict["UnifiedProcedure"] = File.ReadAllText(unifiedPath);
            if (File.Exists(headerPath)) dict["_Header"] = File.ReadAllText(headerPath); else dict["_Header"] = "// <auto-generated/>";
            return new InMemoryTemplateLoader(dict);
        }
        public bool TryLoad(string name, out string content) => _templates.TryGetValue(name, out content);
        public System.Collections.Generic.IEnumerable<string> ListNames() => _templates.Keys;
    }

    private static string DeriveRepoRootFromAssembly()
    {
        var baseDir = AppContext.BaseDirectory; // tests bin path
        var dir = new DirectoryInfo(baseDir);
        for (int i = 0; i < 12 && dir != null; i++)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, "src", "SpocRVNext", "Templates"))) return dir.FullName;
            dir = dir.Parent;
        }
        return Directory.GetCurrentDirectory();
    }
}

using System;
using System.IO;
using System.Linq;
using Xunit;
using SpocR.SpocRVNext.Engine;
using SpocR.SpocRVNext.Metadata;
using SpocR.SpocRVNext.Generators;

namespace SpocR.Tests.SpocRVNext.Generators;

public class JsonResultSetTypeMappingTests
{
    [Fact]
    public void JsonResultSet_Should_Remap_StringColumns_ToStrongTypes()
    {
        // Arrange: snapshot with one JSON result set (FOR JSON PATH) having columns that originally would be inferred as nvarchar.
        // We simulate post-snapshot state where fields have baseline CLR types (string) and SqlTypeName metadata set.
        var root = Path.Combine(Path.GetTempPath(), "spocr-json-remap-" + Guid.NewGuid().ToString("N"));
        var schemaDir = Path.Combine(root, ".spocr", "schema");
        Directory.CreateDirectory(schemaDir);
        var json = """
        {
          "Procedures": [
            {
              "Name": "WorkflowListAsJson",
              "SchemaName": "dbo",
              "OperationName": "dbo__WorkflowListAsJson",
              "Sql": "CREATE PROCEDURE dbo.WorkflowListAsJson AS SELECT Id as workflowId, CreatedOn as createdOn, IsActive as isActive FROM dbo.Workflows FOR JSON PATH;",
              "InputParameters": [],
              "OutputParameters": [],
              "ResultSets": [
                {
                  "ReturnsJson": true,
                  "ReturnsJsonArray": true,
                  "Columns": [
                    { "Name": "workflowId", "SqlTypeName": "int", "IsNullable": false },
                    { "Name": "createdOn", "SqlTypeName": "datetime2", "IsNullable": false },
                    { "Name": "isActive", "SqlTypeName": "bit", "IsNullable": false }
                  ]
                }
              ]
            }
          ]
        }
        """;
        File.WriteAllText(Path.Combine(schemaDir, "legacy.json"), json);
        var provider = new SchemaMetadataProvider(root);
        var proc = provider.GetProcedures().Single();
        // Before generation, baseline field CLR types are mapped by provider (int/datetime2/bit -> int/DateTime/bool)
        // We artificially override them to string to simulate pre-remap baseline if needed (but provider already maps correctly based on SqlTypeName).
        // The generator's JSON remap should keep them as strong types (not downgrade to string). Test ensures no accidental regression.
        var engine = new SimpleTemplateEngine();
        var repoRoot = DeriveRepoRootFromAssembly();
        var loader = InMemoryTemplateLoader.Create(repoRoot);
        var gen = new ProceduresGenerator(engine, () => provider.GetProcedures(), loader, root, null);
        var outDir = Path.Combine(root, "generated");
        Directory.CreateDirectory(outDir);
        gen.Generate("TestNs", outDir);

        var generatedFile = Directory.GetFiles(outDir, "*.cs", SearchOption.AllDirectories)
          .Select(f => new { f, text = File.ReadAllText(f) })
          .FirstOrDefault(x => x.text.Contains("workflowId") && x.text.Contains("record struct"));
        Assert.NotNull(generatedFile);
        var code = generatedFile!.text;
        // Assert: property types in record struct are strong types (int, DateTime, bool)
        Assert.Contains("int workflowId", code);
        Assert.Contains("DateTime createdOn", code);
        Assert.Contains("bool isActive", code);
    }

    private sealed class InMemoryTemplateLoader : SpocR.SpocRVNext.Engine.ITemplateLoader
    {
        private readonly System.Collections.Generic.Dictionary<string, string> _templates;
        private InMemoryTemplateLoader(System.Collections.Generic.Dictionary<string, string> templates) { _templates = templates; }
        public static InMemoryTemplateLoader Create(string repoRoot)
        {
            var dict = new System.Collections.Generic.Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            string unifiedPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "Procedures", "UnifiedProcedure.spt");
            string headerPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "_Header.spt");
            if (File.Exists(unifiedPath)) dict["UnifiedProcedure"] = File.ReadAllText(unifiedPath);
            if (File.Exists(headerPath)) dict["_Header"] = File.ReadAllText(headerPath); else dict["_Header"] = "// <auto-generated/>";
            return new InMemoryTemplateLoader(dict);
        }
        public bool TryLoad(string name, out string content) => _templates.TryGetValue(name, out content);
        public System.Collections.Generic.IEnumerable<string> ListNames() => _templates.Keys;
    }

    private static string DeriveRepoRootFromAssembly()
    {
        var baseDir = AppContext.BaseDirectory; // tests bin path
        var dir = new DirectoryInfo(baseDir);
        for (int i = 0; i < 12 && dir != null; i++)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, "src", "SpocRVNext", "Templates"))) return dir.FullName;
            dir = dir.Parent;
        }
        return Directory.GetCurrentDirectory();
    }
}

using System;
using System.IO;
using System.Linq;
using System.Text.Json;
using Xunit;
using SpocR.SpocRVNext.Engine;
using SpocR.SpocRVNext.Metadata;
using SpocR.SpocRVNext.Generators;

namespace SpocR.Tests.SpocRVNext.Generators;

/// <summary>
/// Ensures rowversion/timestamp JSON columns map to byte[] and can deserialize from Base64 tokens.
/// SQL server FOR JSON emits binary as Base64 strings; generator should expose byte[] properties.
/// </summary>
public class JsonResultSetRowVersionRoundtripTests
{
    [Fact]
    public void RowVersion_Should_Map_To_ByteArray_And_Deserialize_From_Base64()
    {
        var root = Path.Combine(Path.GetTempPath(), "spocr-json-rowver-" + Guid.NewGuid().ToString("N"));
        var schemaDir = Path.Combine(root, ".spocr", "schema");
        Directory.CreateDirectory(schemaDir);
        var json = """
        {
          "Procedures": [
            {
              "Name": "WorkflowAuditAsJson",
              "SchemaName": "dbo",
              "OperationName": "dbo__WorkflowAuditAsJson",
              "Sql": "CREATE PROCEDURE dbo.WorkflowAuditAsJson AS SELECT CAST(1 as int) as workflowId, CAST(0x0102030405 as rowversion) as rowVersion FOR JSON PATH;",
              "InputParameters": [],
              "OutputParameters": [],
              "ResultSets": [
                {
                  "ReturnsJson": true,
                  "ReturnsJsonArray": true,
                  "Columns": [
                    { "Name": "workflowId", "SqlTypeName": "int", "IsNullable": false },
                    { "Name": "rowVersion", "SqlTypeName": "rowversion", "IsNullable": false }
                  ]
                }
              ]
            }
          ]
        }
        """;
        File.WriteAllText(Path.Combine(schemaDir, "legacy.json"), json);
        var provider = new SchemaMetadataProvider(root);
        var engine = new SimpleTemplateEngine();
        var repoRoot = DeriveRepoRootFromAssembly();
        var loader = InMemoryTemplateLoader.Create(repoRoot);
        var gen = new ProceduresGenerator(engine, () => provider.GetProcedures(), loader, root, null);
        var outDir = Path.Combine(root, "generated");
        Directory.CreateDirectory(outDir);
        gen.Generate("TestNs", outDir);
        var generatedFile = Directory.GetFiles(outDir, "*.cs", SearchOption.AllDirectories)
            .Select(f => new { f, text = File.ReadAllText(f) })
            .First(x => x.text.Contains("WorkflowAuditAsJson"));
        var code = generatedFile.text;
        Assert.Contains("int workflowId", code);
        Assert.Contains("byte[] rowVersion", code); // Strong type mapping

        // Simulate FOR JSON output: Base64 for binary 0x01 02 03 04 05
        var bytes = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05 };
        var base64 = Convert.ToBase64String(bytes);
        // Build JSON array payload with Base64; escape quotes inside interpolated string
        var payload = $"[{{\"workflowId\":1,\"rowVersion\":\"{base64}\"}}]";
        var typed = JsonSerializer.Deserialize<System.Collections.Generic.List<WorkflowAuditAsJsonResult>>(payload)!;
        Assert.Single(typed);
        var row = typed[0];
        Assert.Equal(1, row.workflowId);
        Assert.Equal(bytes, row.rowVersion);
    }

    private readonly record struct WorkflowAuditAsJsonResult(int workflowId, byte[] rowVersion);

    private sealed class InMemoryTemplateLoader : SpocR.SpocRVNext.Engine.ITemplateLoader
    {
        private readonly System.Collections.Generic.Dictionary<string, string> _templates;
        private InMemoryTemplateLoader(System.Collections.Generic.Dictionary<string, string> templates) { _templates = templates; }
        public static InMemoryTemplateLoader Create(string repoRoot)
        {
            var dict = new System.Collections.Generic.Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            string unifiedPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "Procedures", "UnifiedProcedure.spt");
            string headerPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "_Header.spt");
            if (File.Exists(unifiedPath)) dict["UnifiedProcedure"] = File.ReadAllText(unifiedPath);
            if (File.Exists(headerPath)) dict["_Header"] = File.ReadAllText(headerPath); else dict["_Header"] = "// <auto-generated/>";
            return new InMemoryTemplateLoader(dict);
        }
        public bool TryLoad(string name, out string content) => _templates.TryGetValue(name, out content);
        public System.Collections.Generic.IEnumerable<string> ListNames() => _templates.Keys;
    }

    private static string DeriveRepoRootFromAssembly()
    {
        var baseDir = AppContext.BaseDirectory; // tests bin path
        var dir = new DirectoryInfo(baseDir);
        for (int i = 0; i < 12 && dir != null; i++)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, "src", "SpocRVNext", "Templates"))) return dir.FullName;
            dir = dir.Parent;
        }
        return Directory.GetCurrentDirectory();
    }
}

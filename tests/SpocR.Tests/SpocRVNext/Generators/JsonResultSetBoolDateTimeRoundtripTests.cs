using System;
using System.IO;
using System.Linq;
using System.Text.Json;
using Xunit;
using SpocR.SpocRVNext.Engine;
using SpocR.SpocRVNext.Metadata;
using SpocR.SpocRVNext.Generators;

namespace SpocR.Tests.SpocRVNext.Generators;

/// <summary>
/// Validates that a JSON result set with bit & datetime2 columns is generated with strong types (bool / DateTime)
/// and can deserialize without any LenientStringConverter fallback involvement.
/// We inspect generated code and perform an actual JsonSerializer roundtrip using an equivalent local record.
/// </summary>
public class JsonResultSetBoolDateTimeRoundtripTests
{
    [Fact]
    public void GeneratedJsonResultSet_Should_Contain_StrongTypes_And_No_LenientStringConverter()
    {
        var root = Path.Combine(Path.GetTempPath(), "spocr-json-bool-dt-" + Guid.NewGuid().ToString("N"));
        var schemaDir = Path.Combine(root, ".spocr", "schema");
        Directory.CreateDirectory(schemaDir);
        var json = """
        {
          "Procedures": [
            {
              "Name": "AuditStatusListAsJson",
              "SchemaName": "dbo",
              "OperationName": "dbo__AuditStatusListAsJson",
              "Sql": "CREATE PROCEDURE dbo.AuditStatusListAsJson AS SELECT CAST(42 as int) as auditId, CAST(1 as bit) as isActive, CAST('2025-10-21T12:34:56Z' as datetime2) as createdOn FOR JSON PATH;",
              "InputParameters": [],
              "OutputParameters": [],
              "ResultSets": [
                {
                  "ReturnsJson": true,
                  "ReturnsJsonArray": true,
                  "Columns": [
                    { "Name": "auditId", "SqlTypeName": "int", "IsNullable": false },
                    { "Name": "isActive", "SqlTypeName": "bit", "IsNullable": false },
                    { "Name": "createdOn", "SqlTypeName": "datetime2", "IsNullable": false }
                  ]
                }
              ]
            }
          ]
        }
        """;
        File.WriteAllText(Path.Combine(schemaDir, "legacy.json"), json);
        var provider = new SchemaMetadataProvider(root);
        var engine = new SimpleTemplateEngine();
        var repoRoot = DeriveRepoRootFromAssembly();
        var loader = InMemoryTemplateLoader.Create(repoRoot);
        var gen = new ProceduresGenerator(engine, () => provider.GetProcedures(), loader, root, null);
        var outDir = Path.Combine(root, "generated");
        Directory.CreateDirectory(outDir);
        gen.Generate("TestNs", outDir);
        var generatedFile = Directory.GetFiles(outDir, "*.cs", SearchOption.AllDirectories)
            .Select(f => new { f, text = File.ReadAllText(f) })
            .First(x => x.text.Contains("AuditStatusListAsJson"));
        var code = generatedFile.text;
        Assert.Contains("int auditId", code);
        Assert.Contains("bool isActive", code);
        Assert.Contains("DateTime createdOn", code);
        Assert.DoesNotContain("LenientStringConverter", code); // ensure not relying on lenient fallback

        // Roundtrip: deserialize JSON array payload into local strongly typed record (shape equivalent)
        var payload = "[{\"auditId\":42,\"isActive\":true,\"createdOn\":\"2025-10-21T12:34:56Z\"}]";
        var typed = JsonSerializer.Deserialize<System.Collections.Generic.List<AuditStatusListAsJsonResult>>(payload)!;
        Assert.Single(typed);
        var row = typed[0];
        Assert.Equal(42, row.auditId);
        Assert.True(row.isActive);
        Assert.Equal(DateTime.Parse("2025-10-21T12:34:56Z").ToUniversalTime(), row.createdOn.ToUniversalTime());
    }

    // Local record matching expected generator output for JSON result set
    private readonly record struct AuditStatusListAsJsonResult(int auditId, bool isActive, DateTime createdOn);

    private sealed class InMemoryTemplateLoader : SpocR.SpocRVNext.Engine.ITemplateLoader
    {
        private readonly System.Collections.Generic.Dictionary<string, string> _templates;
        private InMemoryTemplateLoader(System.Collections.Generic.Dictionary<string, string> templates) { _templates = templates; }
        public static InMemoryTemplateLoader Create(string repoRoot)
        {
            var dict = new System.Collections.Generic.Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            string unifiedPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "Procedures", "UnifiedProcedure.spt");
            string headerPath = Path.Combine(repoRoot, "src", "SpocRVNext", "Templates", "_Header.spt");
            if (File.Exists(unifiedPath)) dict["UnifiedProcedure"] = File.ReadAllText(unifiedPath);
            if (File.Exists(headerPath)) dict["_Header"] = File.ReadAllText(headerPath); else dict["_Header"] = "// <auto-generated/>";
            return new InMemoryTemplateLoader(dict);
        }
        public bool TryLoad(string name, out string content) => _templates.TryGetValue(name, out content);
        public System.Collections.Generic.IEnumerable<string> ListNames() => _templates.Keys;
    }

    private static string DeriveRepoRootFromAssembly()
    {
        var baseDir = AppContext.BaseDirectory; // tests bin path
        var dir = new DirectoryInfo(baseDir);
        for (int i = 0; i < 12 && dir != null; i++)
        {
            if (Directory.Exists(Path.Combine(dir.FullName, "src", "SpocRVNext", "Templates"))) return dir.FullName;
            dir = dir.Parent;
        }
        return Directory.GetCurrentDirectory();
    }
}

// <auto-generated/>
// SpocR v4.5 Bridge Phase (vNext generator). Do not edit this file directly.
// Changes may be overwritten. For customization extend generated partials.

#nullable enable
namespace RestApi.SpocR.Samples;

using RestApi.SpocR;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

public readonly record struct SumWithOutputInput(
    int? A,
    int? B
);

public readonly record struct SumWithOutputOutput(
    int? Sum,
    bool? Success
);

public readonly record struct SumWithOutputResult(
    int? Result
);

public sealed class SumWithOutputAggregate
{
	public bool Success { get; init; }
	public string? Error { get; init; }
	public SumWithOutputOutput? Output { get; init; }
	public IReadOnlyList<SumWithOutputResult> Result { get; init; } = Array.Empty<SumWithOutputResult>();
	
}

internal static partial class SumWithOutputPlan
{
	private static ProcedureExecutionPlan? _cached;
	public static ProcedureExecutionPlan Instance => _cached ??= Create();
	private static ProcedureExecutionPlan Create()
	{

	var parameters = new ProcedureParameter[]
	{
            new("@A", System.Data.DbType.Int32, 4, false, true),
            new("@B", System.Data.DbType.Int32, 4, false, true),
            new("@Sum", System.Data.DbType.Int32, 4, true, true),
            new("@Success", System.Data.DbType.Boolean, 1, true, true),
        };

	var resultSets = new ResultSetMapping[]
	{
            new("ResultSet1", async (r, ct) =>
    {
		var list = new System.Collections.Generic.List<object>(); int o0=ReaderUtil.TryGetOrdinal(r, "Result"); if (System.Environment.GetEnvironmentVariable("SPOCR_DUMP_FIRST_ROW") == "1") ReaderUtil.DumpFirstRow(r); while (await r.ReadAsync(ct).ConfigureAwait(false)) { list.Add(new SumWithOutputResult(o0 < 0 ? null : (r.IsDBNull(o0) ? null : (int?)r.GetInt32(o0)))); } return list;
    }),

        };

		object? OutputFactory(IReadOnlyDictionary<string, object?> values) => new SumWithOutputOutput(values.TryGetValue("Sum", out var v_Sum) ? (int?)v_Sum : default, values.TryGetValue("Success", out var v_Success) ? (bool?)v_Success : default);
		object AggregateFactory(bool success, string? error, object? output, IReadOnlyDictionary<string, object?> outputs, object[] rs)
		{
			return new SumWithOutputAggregate
			{
				Success = success,
				Error = error,
				Output = (SumWithOutputOutput?)output,
				// ResultSet 0 â†’ Result (robust list/array handling)
				Result = rs.Length > 0 && rs[0] is object[] rows0 ? Array.ConvertAll(rows0, o => (SumWithOutputResult)o).ToList() : (rs.Length > 0 && rs[0] is System.Collections.Generic.List<object> list0 ? Array.ConvertAll(list0.ToArray(), o => (SumWithOutputResult)o).ToList() : Array.Empty<SumWithOutputResult>())
			};
		};
		void Binder(DbCommand cmd, object? state)
		{
            var input = (SumWithOutputInput)state!;
            cmd.Parameters["@A"].Value = input.A;
            cmd.Parameters["@B"].Value = input.B;

		}
		return new ProcedureExecutionPlan(
			"samples.SumWithOutput", parameters, resultSets, OutputFactory, AggregateFactory, Binder);
	}
}

/// <summary>Convenience extension for executing 'samples.SumWithOutput' via an <see cref="ISpocRDbContext"/>.</summary>
public static class SumWithOutputExtensions
{
	public static async Task<SumWithOutputAggregate> SumWithOutputAsync(this ISpocRDbContext db, SumWithOutputInput input, CancellationToken cancellationToken = default)
	{
		await using var conn = await db.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
		return await SumWithOutputProcedure.ExecuteAsync(conn, input, cancellationToken).ConfigureAwait(false);
	}
}

/// <summary>Low-level execution wrapper for a single stored procedure invocation.</summary>
public static class SumWithOutputProcedure
{
	public const string Name = "samples.SumWithOutput";
	public static Task<SumWithOutputAggregate> ExecuteAsync(DbConnection connection, SumWithOutputInput input, CancellationToken cancellationToken = default)
	{
		return ProcedureExecutor.ExecuteAsync<SumWithOutputAggregate>(connection, SumWithOutputPlan.Instance, input, cancellationToken);
	}
}

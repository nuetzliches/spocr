/// <summary>Auto-generated by SpocR. DO NOT EDIT. Changes will be overwritten on rebuild.</summary>
/// <remarks>Generated at 2025-10-13 17:15:31Z</remarks>
/// <summary>Generated database context (ADO.NET lightweight). Extend via partials.</summary>
namespace RestApi.SpocR;

using System.Data.Common;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.SqlClient;

public partial class SpocRDbContext : ISpocRDbContext
{
    private readonly SpocRDbContextOptions _options;

    public SpocRDbContext(SpocRDbContextOptions options)
    {
        if (string.IsNullOrWhiteSpace(options.ConnectionString))
            throw new System.ArgumentException("ConnectionString must be provided", nameof(options));
        _options = options;
        if (_options.CommandTimeoutSeconds is null or <= 0)
            _options.CommandTimeoutSeconds = 30;
    }

    public int CommandTimeoutSeconds => _options.CommandTimeoutSeconds ?? 30;

    public DbConnection OpenConnection()
    {
        var sw = _options.EnableDiagnostics ? Stopwatch.StartNew() : null;
        int attempt = 0;
        int max = _options.MaxOpenRetries.GetValueOrDefault(0);
        int delay = _options.RetryDelayMs.GetValueOrDefault(200);
        while (true)
        {
            try
            {
                var conn = new SqlConnection(_options.ConnectionString);
                conn.Open();
                if (_options.EnableDiagnostics)
                {
                    sw!.Stop();
                    System.Diagnostics.Debug.WriteLine($"[SpocRDbContext] OpenConnection latency={sw.ElapsedMilliseconds}ms attempts={attempt+1}");
                }
                return conn;
            }
            catch (SqlException ex) when (attempt < max)
            {
                attempt++;
                if (_options.EnableDiagnostics)
                {
                    System.Diagnostics.Debug.WriteLine($"[SpocRDbContext] OpenConnection retry {attempt}/{max} after error: {ex.Message}");
                }
                Thread.Sleep(delay);
                continue;
            }
            catch (SqlException ex)
            {
                if (_options.EnableDiagnostics)
                {
                    System.Diagnostics.Debug.WriteLine($"[SpocRDbContext] OpenConnection failed: {ex.Message}");
                }
                throw;
            }
        }
    }

    public async Task<DbConnection> OpenConnectionAsync(CancellationToken cancellationToken = default)
    {
        var sw = _options.EnableDiagnostics ? Stopwatch.StartNew() : null;
        int attempt = 0;
        int max = _options.MaxOpenRetries.GetValueOrDefault(0);
        int delay = _options.RetryDelayMs.GetValueOrDefault(200);
        while (true)
        {
            try
            {
                var conn = new SqlConnection(_options.ConnectionString);
                await conn.OpenAsync(cancellationToken).ConfigureAwait(false);
                if (_options.EnableDiagnostics)
                {
                    sw!.Stop();
                    System.Diagnostics.Debug.WriteLine($"[SpocRDbContext] OpenConnectionAsync latency={sw.ElapsedMilliseconds}ms attempts={attempt+1}");
                }
                return conn;
            }
            catch (SqlException ex) when (attempt < max)
            {
                attempt++;
                if (_options.EnableDiagnostics)
                {
                    System.Diagnostics.Debug.WriteLine($"[SpocRDbContext] OpenConnectionAsync retry {attempt}/{max} after error: {ex.Message}");
                }
                await Task.Delay(delay, cancellationToken).ConfigureAwait(false);
                continue;
            }
            catch (SqlException ex)
            {
                if (_options.EnableDiagnostics)
                {
                    System.Diagnostics.Debug.WriteLine($"[SpocRDbContext] OpenConnectionAsync failed: {ex.Message}");
                }
                throw;
            }
        }
    }

    public async Task<bool> HealthCheckAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            await using var conn = new SqlConnection(_options.ConnectionString);
            await conn.OpenAsync(cancellationToken).ConfigureAwait(false);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

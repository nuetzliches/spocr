{{ HEADER }}
#nullable enable
namespace {{ Namespace }};

{{ UsingDirectives }}

{{#if HasInput}}
public readonly record struct {{ InputTypeName }}(
{{#each InputParameters}}    {{ ClrType }} {{ PropertyName }}{{ Comma }}
{{/each}});
{{/if}}

{{#if HasOutput}}
public readonly record struct {{ OutputTypeName }}(
{{#each OutputFields}}    {{ ClrType }} {{ PropertyName }}{{ Comma }}
{{/each}});
{{/if}}

{{#if HasResultSets}}
{{#each ResultSets}}public readonly record struct {{ TypeName }}(
{{ FieldsBlock }}
);

{{/each}}{{/if}}

public sealed class {{ UnifiedResultTypeName }}
{
	public bool Success { get; init; }
	public string? Error { get; init; }
	{{#if HasOutput}}public {{ OutputTypeName }}? Output { get; init; }
	{{/if}}{{#if HasResultSets}}{{#each ResultSets}}public IReadOnlyList<{{ TypeName }}> {{ PropName }} { get; init; } = Array.Empty<{{ TypeName }}>();
	{{/each}}{{/if}}
}

internal static partial class {{ PlanTypeName }}
{
	private static ProcedureExecutionPlan? _cached;
	public static ProcedureExecutionPlan Instance => _cached ??= Create();
	private static ProcedureExecutionPlan Create()
	{
{{#if HasParameters}}
	var parameters = new ProcedureParameter[]
	{
{{#each ParameterLines}}            {{ this }},
{{/each}}        };
{{else}}
	var parameters = Array.Empty<ProcedureParameter>();
{{/if}}

{{#if HasResultSets}}
	var resultSets = new ResultSetMapping[]
	{
{{#each ResultSets}}            new("{{ Name }}", async (r, ct) =>
	    {
		var list = new List<object>();
{{ OrdinalDecls }}
		while (await r.ReadAsync(ct).ConfigureAwait(false))
		{
		    list.Add(new {{ TypeName }}({{ FieldExprs }}));
		}
		return list;
	    }),

{{/each}}        };
{{else}}
	var resultSets = Array.Empty<ResultSetMapping>();
{{/if}}

		object? OutputFactory(IReadOnlyDictionary<string, object?> values) => {{#if HasOutput}}new {{ OutputTypeName }}({{ OutputFactoryArgs }}){{else}}null{{/if}};
		object AggregateFactory(bool success, string? error, object? output, IReadOnlyDictionary<string, object?> outputs, object[] rs)
		{
			return new {{ UnifiedResultTypeName }}
			{
				Success = success,
				Error = error{{#if HasOutput}},
				Output = ({{ OutputTypeName }}?)output{{/if}}{{#if HasResultSets}}{{#each ResultSets}},
				// ResultSet {{ Index }} â†’ {{ PropName }} (robust list/array handling)
				{{ PropName }} = {{ AggregateAssignment }}{{/each}}{{/if}}
			};
		};
		void Binder(DbCommand cmd, object? state)
		{
{{#if HasInput}}            var input = ({{ InputTypeName }})state!;
{{#each InputAssignments}}            {{ this }}
{{/each}}{{/if}}
		}
		return new ProcedureExecutionPlan(
			"{{ ProcedureFullName }}", parameters, resultSets, OutputFactory, AggregateFactory, Binder);
	}
}

/// <summary>Convenience extension for executing '{{ ProcedureFullName }}' via an <see cref="ISpocRDbContext"/>.</summary>
public static class {{ ProcedureTypeName }}Extensions
{
	public static async Task<{{ UnifiedResultTypeName }}> {{ ProcedureTypeName }}Async(this ISpocRDbContext db{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		await using var conn = await db.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
		return await {{ ProcedureTypeName }}Procedure.ExecuteAsync(conn{{#if HasInput}}, input{{/if}}, cancellationToken).ConfigureAwait(false);
	}
}

/// <summary>Low-level execution wrapper for a single stored procedure invocation.</summary>
public static class {{ ProcedureTypeName }}Procedure
{
	public const string Name = "{{ ProcedureFullName }}";
	public static Task<{{ UnifiedResultTypeName }}> ExecuteAsync(DbConnection connection{{#if HasInput}}, {{ InputTypeName }} input{{/if}}, CancellationToken cancellationToken = default)
	{
		return ProcedureExecutor.ExecuteAsync<{{ UnifiedResultTypeName }}>(connection, {{ PlanTypeName }}.Instance, {{#if HasInput}}input{{else}}null{{/if}}, cancellationToken);
	}
}

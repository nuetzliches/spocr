using System;
using System.IO;
using System.Linq;
using System.Text;
using SpocRVNext.Configuration;
using SpocRVNext.Metadata;
using SpocR.SpocRVNext.Engine;

namespace SpocR.SpocRVNext.Generators;

public sealed class TableTypesGenerator
{
    private readonly EnvConfiguration _cfg;
    private readonly ITableTypeMetadataProvider _provider;
    private readonly ITemplateRenderer _renderer;
    private readonly ITemplateLoader? _loader;

    public TableTypesGenerator(EnvConfiguration cfg, ITableTypeMetadataProvider provider, ITemplateRenderer renderer, ITemplateLoader? loader = null)
    {
        _cfg = cfg;
        _provider = provider;
        _renderer = renderer;
        _loader = loader;
    }

    public int Generate()
    {
        var types = _provider.GetAll();
        if (types.Count == 0) return 0;
        var resolver = new NamespaceResolver(_cfg);
        var ns = resolver.Resolve();
        var rootOut = Path.Combine(Directory.GetCurrentDirectory(), _cfg.OutputDir ?? "SpocR");
        Directory.CreateDirectory(rootOut);
        var written = 0;
        string? tableTypeTemplate = null;
        if (_loader != null && _loader.TryLoad("TableType", out var tpl)) tableTypeTemplate = tpl;

        // Ensure interface exists once (ITableType)
        var interfacePath = Path.Combine(rootOut, "ITableType.cs");
        if (!File.Exists(interfacePath))
        {
            string ifaceCode;
            if (_loader != null && _loader.TryLoad("ITableType", out var ifaceTpl))
            {
                var ifaceModel = new { Namespace = ns };
                ifaceCode = _renderer.Render(ifaceTpl, ifaceModel);
            }
            else
            {
                ifaceCode = $"// <auto-generated/>\nnamespace {ns}.TableTypes;\n\npublic interface ITableType {{}}\n";
            }
            File.WriteAllText(interfacePath, ifaceCode, Encoding.UTF8);
            written++;
        }
        foreach (var tt in types.OrderBy(t => t.Schema).ThenBy(t => t.Name))
        {
            var schemaDir = Path.Combine(rootOut, tt.Schema);
            Directory.CreateDirectory(schemaDir);
            var cols = tt.Columns.Select(c => new
            {
                c.Name,
                PropertyName = Sanitize(c.Name),
                ClrType = MapSqlToClr(c.SqlType, c.IsNullable),
            }).ToList();
            var model = new
            {
                Namespace = ns,
                tt.Schema,
                tt.Name,
                TypeName = Sanitize(tt.Name) + "TableType",
                Columns = cols.Select((c, idx) => new { c.PropertyName, c.ClrType, Separator = idx == cols.Count - 1 ? string.Empty : "," }).ToList(),
                ColumnsCount = cols.Count
            };
            string code;
            if (tableTypeTemplate != null)
            {
                code = _renderer.Render(tableTypeTemplate, model);
            }
            else
            {
                code = RenderInline(ns, tt.Schema, tt.Name, tt.Columns.Select(c => (c.Name, c.SqlType, c.IsNullable, c.MaxLength)).ToArray());
            }
            var fileName = Sanitize(tt.Name) + "TableType.cs";
            File.WriteAllText(Path.Combine(schemaDir, fileName), code, Encoding.UTF8);
            written++;
        }
        return written;
    }

    private static string Sanitize(string input)
    {
        var s = new string(input.Where(ch => char.IsLetterOrDigit(ch) || ch == '_').ToArray());
        if (string.IsNullOrWhiteSpace(s)) s = "TableType";
        if (char.IsDigit(s[0])) s = "N" + s;
        return s;
    }

    private static string RenderInline(string ns, string schema, string name, (string col, string sql, bool nullable, int? max)[] cols)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/> Generated by SpocR vNext TableTypesGenerator");
    sb.AppendLine($"namespace {ns}.TableTypes;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// User Defined Table Type {schema}.{name}");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public readonly record struct {Sanitize(name)}TableType(");
        for (int i = 0; i < cols.Length; i++)
        {
            var (col, sql, nullable, max) = cols[i];
            var clr = MapSqlToClr(sql, nullable);
            var comma = i == cols.Length - 1 ? string.Empty : ",";
            sb.Append("    ").Append(clr).Append(' ').Append(Sanitize(col)).Append(comma).AppendLine();
        }
        sb.AppendLine(") : ITableType;");
        return sb.ToString();
    }

    private static string MapSqlToClr(string sql, bool nullable)
    {
        sql = sql.ToLowerInvariant();
        string core = sql switch
        {
            var s when s.StartsWith("int") => "int",
            var s when s.StartsWith("bigint") => "long",
            var s when s.StartsWith("smallint") => "short",
            var s when s.StartsWith("tinyint") => "byte",
            var s when s.StartsWith("bit") => "bool",
            var s when s.StartsWith("decimal") || s.StartsWith("numeric") => "decimal",
            var s when s.StartsWith("float") => "double",
            var s when s.StartsWith("real") => "float",
            var s when s.Contains("date") || s.Contains("time") => "DateTime",
            var s when s.Contains("uniqueidentifier") => "Guid",
            var s when s.Contains("binary") || s.Contains("varbinary") => "byte[]",
            var s when s.Contains("char") || s.Contains("text") => "string",
            _ => "string"
        };
        if (core != "string" && core != "byte[]" && nullable) core += "?";
        return core;
    }
}